# Drizzle 데이터베이스 상호작용 규칙

이 프로젝트의 모든 데이터베이스 상호작용은 **Drizzle ORM**을 사용하며, 타입 안전성과 스키마 일관성을 보장해야 합니다.

## 필수 사항

### 1. 데이터베이스 클라이언트 사용
```typescript
import { db } from '@/db';
```
- 모든 데이터베이스 쿼리는 `src/db/index.ts`에서 내보낸 `db` 클라이언트를 사용해야 합니다.

### 2. 스키마 임포트
```typescript
import { 
  apiCallLogs,
  weatherEmbeddings,
  hourlyWeatherData,
  dailyWeatherData,
  userLocations,
  emailSendLogs,
  individualEmailLogs,
  kakaoMessages,
  webhookLogs,
  // ... 기타 필요한 테이블
} from '@/db/schema';
import { eq, and, or, desc, asc, sql, count } from 'drizzle-orm';
```
- 모든 테이블 정의는 `src/db/schema.ts`에서 가져와야 합니다.

### 3. 타입 안전성 가드 (필수 사용)
모든 nullable 필드 처리 시 다음 패턴을 사용해야 합니다:

```typescript
// 타입 가드 유틸리티 (필수 구현)
export const DatabaseTypeGuards = {
  ensureString: (value: string | null | undefined, fallback = ''): string => 
    value ?? fallback,
  
  ensureNumber: (value: number | null | undefined, fallback = 0): number => 
    value ?? fallback,
    
  ensureDate: (value: Date | null | undefined): Date => 
    value ?? new Date(),
    
  ensureBoolean: (value: boolean | null | undefined, fallback = false): boolean => 
    value ?? fallback,
};

// 사용 예시 (필수 패턴)
const location = DatabaseTypeGuards.ensureString(record.locationName, 'Unknown Location');
const temperature = DatabaseTypeGuards.ensureString(record.temperature, '0');
```

### 4. 스키마 필드 검증 (필수)
테이블 사용 전 필수 필드 존재 여부를 검증해야 합니다:

```typescript
// 스키마 검증 함수 (필수 구현)
export function validateTableSchema<T extends Record<string, any>>(
  table: T, 
  requiredFields: (keyof T)[],
  tableName: string
): void {
  const missingFields = requiredFields.filter(field => !(field in table));
  
  if (missingFields.length > 0) {
    throw new Error(
      `❌ 테이블 '${tableName}'에서 필수 필드가 누락됨: ${missingFields.join(', ')}`
    );
  }
}

// 사용 예시 (테이블 사용 전 필수 실행)
validateTableSchema(
  apiCallLogs, 
  ['service', 'endpoint', 'method', 'statusCode', 'createdAt'],
  'apiCallLogs'
);
```

## 올바른 사용 패턴

### 1. 타입 안전한 쿼리 작성
```typescript
// ✅ 올바른 패턴
const weatherData = await db
  .select({
    id: hourlyWeatherData.id,
    locationKey: hourlyWeatherData.locationKey,
    locationName: hourlyWeatherData.locationName,
    forecastDateTime: hourlyWeatherData.forecastDateTime,
    temperature: hourlyWeatherData.temperature,
    conditions: hourlyWeatherData.conditions,
  })
  .from(hourlyWeatherData)
  .where(
    and(
      eq(hourlyWeatherData.clerkUserId, userId),
      eq(hourlyWeatherData.locationKey, locationKey)
    )
  );

// ✅ null 안전성 보장
const processedData = weatherData.map(record => ({
  location: DatabaseTypeGuards.ensureString(record.locationName, 'Unknown Location'),
  temperature: DatabaseTypeGuards.ensureString(record.temperature, '0'),
  conditions: DatabaseTypeGuards.ensureString(record.conditions, 'Unknown'),
  timestamp: record.forecastDateTime.toISOString(),
}));
```

### 2. Repository 패턴 사용 (권장)
```typescript
export class ApiCallLogRepository {
  // ✅ 타입 안전한 조회
  static async findByService(service: string) {
    return await db
      .select()
      .from(apiCallLogs)
      .where(eq(apiCallLogs.service, service));
  }
  
  // ✅ 통계 조회 (성공/실패 판단)
  static async getDailyStats(service: string, date: string) {
    return await db
      .select({
        totalCalls: count(),
        successfulCalls: sql<number>`COUNT(CASE WHEN ${apiCallLogs.statusCode} >= 200 AND ${apiCallLogs.statusCode} < 300 THEN 1 END)`,
        failedCalls: sql<number>`COUNT(CASE WHEN ${apiCallLogs.statusCode} < 200 OR ${apiCallLogs.statusCode} >= 300 THEN 1 END)`,
        avgResponseTime: sql<number>`AVG(${apiCallLogs.responseTime})`,
      })
      .from(apiCallLogs)
      .where(
        and(
          eq(apiCallLogs.service, service),
          sql`DATE(${apiCallLogs.createdAt}) = ${date}`
        )
      );
  }
  
  // ✅ 안전한 데이터 삽입
  static async create(data: {
    service: string;
    endpoint: string;
    method: string;
    statusCode?: number;
    responseTime?: number;
    errorMessage?: string;
    requestData?: any;
    responseData?: any;
  }) {
    return await db.insert(apiCallLogs).values({
      ...data,
      createdAt: new Date(),
    });
  }
}
```

### 3. 성능 최적화 패턴
```typescript
// ✅ 필요한 필드만 선택
const summary = await db
  .select({
    id: apiCallLogs.id,
    service: apiCallLogs.service,
    statusCode: apiCallLogs.statusCode,
    createdAt: apiCallLogs.createdAt,
  })
  .from(apiCallLogs);

// ✅ 인덱스 활용
const recentLogs = await db
  .select()
  .from(apiCallLogs)
  .where(
    and(
      eq(apiCallLogs.service, service),           // 인덱스 활용
      gte(apiCallLogs.createdAt, startDate)      // 시간 범위 인덱스
    )
  )
  .orderBy(desc(apiCallLogs.createdAt))
  .limit(100);
```

## 금지 사항

### 1. 직접 SQL 사용 금지
```typescript
// ❌ 금지
await db.execute(sql`SELECT * FROM api_call_logs WHERE service = 'test'`);

// ✅ 올바른 방법
await db.select().from(apiCallLogs).where(eq(apiCallLogs.service, 'test'));
```

### 2. 스키마 외부 테이블 정의 금지
```typescript
// ❌ 금지
const customTable = pgTable('custom_table', { ... });

// ✅ 올바른 방법: src/db/schema.ts에 정의 후 임포트
```

### 3. 타입 체크 없는 필드 접근 금지
```typescript
// ❌ 금지 - 존재하지 않는 필드 접근
record.nonExistentField

// ❌ 금지 - null 체크 없는 사용
location: record.locationName  // string | null → string 오류

// ✅ 올바른 방법
location: DatabaseTypeGuards.ensureString(record.locationName, 'Unknown')
```

### 4. 모든 필드 조회 금지 (성능상 이유)
```typescript
// ❌ 성능 저하
const allData = await db.select().from(apiCallLogs);

// ✅ 필요한 필드만 선택
const summary = await db
  .select({
    id: apiCallLogs.id,
    service: apiCallLogs.service,
    statusCode: apiCallLogs.statusCode,
  })
  .from(apiCallLogs);
```

## 사용 가능한 테이블 목록

### 핵심 테이블
- `apiCallLogs`: API 호출 로그 및 통계
- `dailyApiStats`: 일별 API 사용 통계
- `emailSendLogs`: 이메일 발송 로그
- `individualEmailLogs`: 개별 이메일 로그

### 날씨 관련 테이블
- `hourlyWeatherData`: 시간별 날씨 데이터
- `dailyWeatherData`: 일별 날씨 데이터
- `weatherEmbeddings`: 날씨 데이터 임베딩
- `weatherLocationKeys`: 날씨 위치 키

### 대기질 관련 테이블
- `googleHourlyAirQualityData`: Google 시간별 대기질
- `googleDailyAirQualityData`: Google 일별 대기질
- `regionalHourlyAirQuality`: 지역별 시간별 대기질
- `regionalDailyAirQuality`: 지역별 일별 대기질

### 사용자 관련 테이블
- `userProfiles`: 사용자 프로필
- `userLocations`: 사용자 위치 정보
- `userEmailSettings`: 사용자 이메일 설정
- `userSelectedStations`: 사용자 선택 측정소

### 기타 테이블
- `emailSchedules`: 이메일 스케줄
- `kakaoMessages`: 카카오 메시지
- `webhookLogs`: 웹훅 로그
- `chatGptConversations`: ChatGPT 대화 기록
- `marts`: 마트 정보
- `martDiscounts`: 마트 할인 정보
- `martDiscountItems`: 마트 할인 상품

## 스키마 변경 시 체크리스트

### 변경 전
- [ ] 영향받는 파일들 식별
- [ ] 기존 스키마 백업
- [ ] 마이그레이션 계획 수립

### 변경 중
- [ ] `src/db/schema.ts` 업데이트
- [ ] 타입 정의 업데이트
- [ ] 영향받는 모든 파일 수정
- [ ] Repository 클래스 업데이트
- [ ] 타입 가드 함수 업데이트

### 변경 후
- [ ] `npm run type-check` 실행
- [ ] `npm run build` 실행
- [ ] 테스트 실행
- [ ] 문서 업데이트

## 빌드 전 필수 검증

```bash
# 타입 검사
npm run type-check

# 전체 빌드 (모든 타입 오류 감지)
npm run build

# 스키마 일관성 검사 (있는 경우)
npm run validate-schema
```

이 규칙들을 엄격히 준수하여 모든 데이터베이스 상호작용의 타입 안전성과 일관성을 보장하세요.
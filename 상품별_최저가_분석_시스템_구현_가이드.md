# 상품별 최저가 분석 시스템 구현 가이드

## 1. 개요

이 문서는 마트별 전단지 할인 정보를 기반으로 상품별 최저 가격 정보를 도출하는 시스템의 구현 방법을 설명합니다.

### 요구사항
- 전체 마트에 대해 전단지에 등록된 개별 상품별로 최저 가격 정보 도출
- 각 상품에 대한 최저 가격 구입 가능 마트 이름, 할인 날짜, 최저 가격 요약
- 예시: 한돈암돼지 생삼겹살 600g을 최저 가격으로 구입할 수 있는 마트는 은성마트이고, 10월 16일에 11,000원에 구입 가능

### 현재 데이터 구조
- **marts**: 마트 기본 정보
- **martDiscounts**: 마트별 할인 전단지 메타 정보
- **martDiscountItems**: 날짜별 할인 상품 정보 (상품명, 가격 포함)

## 2. 기술 스택

### 핵심 기술
- **Next.js 15** (App Router)
- **TypeScript** (타입 안전성)
- **Drizzle ORM** (데이터베이스 쿼리)
- **PostgreSQL** (관계형 데이터베이스)
- **Zod** (데이터 검증)

### 추가 필요 기술
- **ExcelJS** (엑셀 파일 생성)
- **OpenAI Embeddings** (벡터 임베딩, 선택사항)
- **pgvector** (PostgreSQL 벡터 확장, 선택사항)

## 3. 구현 방법 비교

### 방법 1: 순수 데이터베이스 접근법 ⭐️ **추천**
**장점:**
- 100% 정확한 결과 보장
- 빠른 쿼리 성능
- 실시간 분석 가능
- 오류 발생 가능성 최소

**단점:**
- 상품명 정규화 필요
- 동일 상품의 다른 표기법 처리 어려움

### 방법 2: 벡터 DB + RAG 접근법
**장점:**
- 유사한 상품명 자동 매칭
- 자연어 처리 가능
- AI 기반 인사이트 제공

**단점:**
- 임베딩 비용 발생
- 결과의 정확성 보장 어려움
- 복잡한 구현

### 방법 3: 하이브리드 접근법 ⭐️ **최종 추천**
**1차: 데이터베이스 정확 매칭**
**2차: 벡터 검색으로 유사 상품 보완**

## 4. 최종 추천: 단계별 하이브리드 접근법

### 4.1 1단계: 순수 데이터베이스 접근법 (우선 구현)

**이유:**
- **100% 정확성 보장**: 데이터베이스의 정확한 데이터만 사용
- **빠른 구현**: 기존 스키마 활용 가능
- **실시간 분석**: 쿼리 기반으로 즉시 결과 제공
- **오류 최소화**: 복잡한 AI 로직 없이 단순한 비교 연산

**핵심 구현 로직:**
```sql
-- 상품별 최저가 조회 쿼리 예시
WITH product_prices AS (
  SELECT 
    jsonb_array_elements(mdi.products)->>'name' as product_name,
    CAST(regexp_replace(jsonb_array_elements(mdi.products)->>'price', '[^0-9]', '', 'g') AS INTEGER) as price,
    m.name as mart_name,
    mdi.discount_date,
    ROW_NUMBER() OVER (
      PARTITION BY jsonb_array_elements(mdi.products)->>'name' 
      ORDER BY CAST(regexp_replace(jsonb_array_elements(mdi.products)->>'price', '[^0-9]', '', 'g') AS INTEGER)
    ) as rn
  FROM mart_discount_items mdi
  JOIN mart_discounts md ON mdi.discount_id = md.id
  JOIN marts m ON md.mart_id = m.id
  WHERE mdi.products IS NOT NULL
)
SELECT product_name, price, mart_name, discount_date
FROM product_prices 
WHERE rn = 1
ORDER BY product_name;
```

### 4.2 2단계: 상품명 정규화 시스템 (정확도 향상)

**상품명 정규화 규칙:**
```typescript
function normalizeProductName(name: string): string {
  return name
    .toLowerCase()                    // 소문자 변환
    .replace(/\s+/g, '')             // 공백 제거
    .replace(/[()[\]]/g, '')         // 괄호 제거
    .replace(/[0-9]+g|[0-9]+ml/g, '') // 용량 정보 제거
    .replace(/한돈|국내산|수입산/g, '') // 브랜드/원산지 제거
    .trim();
}
```

### 4.3 3단계: 벡터 검색 보완 (선택사항)

**유사 상품 매칭을 위한 보완 시스템:**
- 정확한 매칭이 안 되는 경우에만 벡터 검색 활용
- 사용자가 수동으로 상품 매핑 설정 가능한 관리 인터페이스 제공

## 5. 구체적 구현 방안

### 5.1 데이터베이스 스키마 확장

```typescript
// 상품 정규화 테이블 (새로 추가)
export const productCatalog = pgTable('product_catalog', {
  id: uuid('id').defaultRandom().primaryKey(),
  normalizedName: text('normalized_name').notNull(), // 정규화된 상품명
  originalNames: jsonb('original_names'), // 원본 상품명 배열
  category: text('category'), // 상품 카테고리
  brand: text('brand'), // 브랜드
  unit: text('unit'), // 단위 (g, ml, 개 등)
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

// 최저가 분석 결과 캐시 테이블 (새로 추가)
export const productBestPrices = pgTable('product_best_prices', {
  id: uuid('id').defaultRandom().primaryKey(),
  productCatalogId: uuid('product_catalog_id').references(() => productCatalog.id),
  martId: uuid('mart_id').references(() => marts.id),
  discountItemId: uuid('discount_item_id').references(() => martDiscountItems.id),
  lowestPrice: text('lowest_price').notNull(),
  discountDate: timestamp('discount_date').notNull(),
  lastUpdated: timestamp('last_updated').defaultNow().notNull(),
});
```

### 5.2 핵심 Server Actions

```typescript
// src/actions/product-analysis.ts
'use server';

import { db } from '@/db';
import { marts, martDiscounts, martDiscountItems, productCatalog, productBestPrices } from '@/db/schema';
import { auth } from '@clerk/nextjs/server';
import { eq, sql, desc, asc } from 'drizzle-orm';
import ExcelJS from 'exceljs';

/**
 * 전체 상품별 최저가 분석
 */
export async function analyzeLowestPrices() {
  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');

  // 1. 모든 할인 상품 데이터 조회
  const allDiscountItems = await db
    .select({
      itemId: martDiscountItems.id,
      martId: martDiscounts.martId,
      martName: marts.name,
      discountDate: martDiscountItems.discountDate,
      products: martDiscountItems.products,
    })
    .from(martDiscountItems)
    .innerJoin(martDiscounts, eq(martDiscountItems.discountId, martDiscounts.id))
    .innerJoin(marts, eq(martDiscounts.martId, marts.id))
    .orderBy(asc(martDiscountItems.discountDate));

  // 2. 상품별 최저가 분석
  const productPriceMap = new Map();
  
  for (const item of allDiscountItems) {
    const products = item.products as Array<{name: string, price: string}>;
    
    for (const product of products || []) {
      const normalizedName = normalizeProductName(product.name);
      const price = parsePrice(product.price);
      
      if (!productPriceMap.has(normalizedName) || 
          productPriceMap.get(normalizedName).price > price) {
        productPriceMap.set(normalizedName, {
          productName: product.name,
          normalizedName,
          price,
          martName: item.martName,
          discountDate: item.discountDate,
          martId: item.martId,
          itemId: item.itemId,
        });
      }
    }
  }

  return Array.from(productPriceMap.values());
}

/**
 * 엑셀 파일 생성
 */
export async function generateLowestPriceExcel() {
  const lowestPrices = await analyzeLowestPrices();
  
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('상품별 최저가');
  
  // 헤더 설정
  worksheet.columns = [
    { header: '상품명', key: 'productName', width: 30 },
    { header: '최저가격', key: 'price', width: 15 },
    { header: '마트명', key: 'martName', width: 20 },
    { header: '할인날짜', key: 'discountDate', width: 15 },
  ];
  
  // 데이터 추가
  lowestPrices.forEach(item => {
    worksheet.addRow({
      productName: item.productName,
      price: `${item.price.toLocaleString()}원`,
      martName: item.martName,
      discountDate: item.discountDate.toLocaleDateString('ko-KR'),
    });
  });
  
  // 스타일 적용
  worksheet.getRow(1).font = { bold: true };
  worksheet.autoFilter = 'A1:D1';
  
  const buffer = await workbook.xlsx.writeBuffer();
  return buffer;
}

/**
 * 상품명 정규화 함수
 */
function normalizeProductName(name: string): string {
  return name
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/[()[\]]/g, '')
    .trim();
}

/**
 * 가격 파싱 함수
 */
function parsePrice(priceStr: string): number {
  return parseInt(priceStr.replace(/[^0-9]/g, '')) || 0;
}
```

### 5.3 벡터 검색 보완 시스템 (선택사항)

```typescript
// src/lib/services/vector-search.ts
import OpenAI from 'openai';
import { db } from '@/db';
import { vectorStore } from '@/db/schema';

export class ProductVectorSearch {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
  }

  /**
   * 상품 정보를 벡터로 임베딩하여 저장
   */
  async embedProductData() {
    const allProducts = await this.getAllUniqueProducts();
    
    for (const product of allProducts) {
      const embedding = await this.createEmbedding(
        `${product.name} ${product.mart} ${product.price}`
      );
      
      await db.insert(vectorStore).values({
        content: JSON.stringify(product),
        metadata: {
          type: 'product',
          productName: product.name,
          martName: product.mart,
          price: product.price,
        },
        embedding: JSON.stringify(embedding),
      });
    }
  }

  /**
   * 유사 상품 검색
   */
  async findSimilarProducts(productName: string, limit = 10) {
    const queryEmbedding = await this.createEmbedding(productName);
    
    // PostgreSQL의 벡터 유사도 검색 사용
    const results = await db.execute(sql`
      SELECT content, metadata, 
             1 - (embedding <=> ${JSON.stringify(queryEmbedding)}) as similarity
      FROM vector_store 
      WHERE metadata->>'type' = 'product'
      ORDER BY embedding <=> ${JSON.stringify(queryEmbedding)}
      LIMIT ${limit}
    `);
    
    return results.rows;
  }

  private async createEmbedding(text: string) {
    const response = await this.openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: text,
    });
    
    return response.data[0].embedding;
  }

  private async getAllUniqueProducts() {
    // 기존 할인 상품 데이터에서 모든 상품 추출
    // 구현 로직...
  }
}
```

## 6. 구현 우선순위 및 단계

### Phase 1: 기본 최저가 분석 시스템 (2-3일)
1. **Server Action 구현**: `analyzeLowestPrices()`
2. **엑셀 생성 기능**: `generateLowestPriceExcel()`
3. **관리자 페이지**: `/admin/mart/price-analysis`
4. **기본 상품명 정규화**

### Phase 2: 정확도 향상 (1-2일)
1. **상품 카탈로그 테이블 추가**
2. **상품명 정규화 고도화**
3. **수동 매핑 관리 인터페이스**

### Phase 3: 벡터 검색 보완 (선택사항, 2-3일)
1. **pgvector 확장 설치**
2. **OpenAI 임베딩 연동**
3. **유사도 검색 시스템**

## 7. 필요한 패키지 설치

```bash
# 엑셀 생성
npm install exceljs

# 벡터 검색 (선택사항)
npm install openai
npm install @types/pg

# PostgreSQL 벡터 확장 (데이터베이스 레벨)
# CREATE EXTENSION vector;
```

## 8. 최종 결론 및 추천사항

### 🎯 **가장 정확하고 오류 없는 방법: 단계별 데이터베이스 접근법**

**1순위 추천: 순수 데이터베이스 접근법**
- ✅ **정확성**: 100% 데이터베이스 기반으로 오류 최소화
- ✅ **성능**: 빠른 SQL 쿼리로 실시간 분석
- ✅ **구현 용이성**: 기존 스키마 활용 가능
- ✅ **유지보수**: 단순한 로직으로 디버깅 쉬움

**2순위 보완: 상품명 정규화**
- 동일 상품의 다른 표기법 처리
- 사용자 정의 매핑 테이블 활용

**3순위 선택사항: 벡터 검색**
- 고도화된 유사 상품 매칭
- 추가 비용과 복잡성 고려 필요

이 방법을 통해 **한돈암돼지 생삼겹살 600g → 은성마트, 10월 16일, 11,000원**과 같은 정확한 최저가 정보를 오류 없이 도출할 수 있습니다.
